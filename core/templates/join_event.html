<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{ event.title }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/@mux/mux-embed@latest"></script>
  <script src="https://unpkg.com/@mux/mux-rtmp-publisher"></script>
  <style>
    body {
      background-color: #000;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 1rem;
    }
    .video-box {
      width: 100%;
      background-color: #111;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      border: 2px solid #333;
      margin-bottom: 1rem;
    }
    #localVideo, #viewerStream {
      width: 100%;
      max-height: 60vh;
      border-radius: 10px;
      border: 2px solid limegreen;
      object-fit: cover;
    }
    .chat {
      background-color: #111;
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
    }
    input, select, button {
      padding: 0.5rem;
      border: none;
      border-radius: 5px;
      margin: 0.2rem;
    }
    input {
      width: 70%;
      background-color: #222;
      color: #fff;
    }
    #sendBtn {
      background-color: limegreen;
      color: #000;
      font-weight: bold;
    }
    #likeBtn {
      background-color: #000;
      color: white;
      border: 2px solid red;
      font-weight: bold;
      transition: background 0.3s, color 0.3s;
    }
    #likeBtn.liked {
      background-color: red;
      color: #fff;
    }
    #leaveChatBtn {
      background-color: #444;
      color: #fff;
      font-weight: bold;
    }
    #sendGiftBtn {
      background-color: orange;
      color: #000;
      font-weight: bold;
    }
    .mic-request-btn {
      width: 100%;
      background: #333;
      color: white;
      padding: 0.6rem;
      margin-top: 0.5rem;
      font-weight: bold;
      border-radius: 5px;
    }
    .viewer-count {
      margin-bottom: 1rem;
    }
    .float-emoji {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2rem;
      animation: floatUp 4s ease-out forwards;
      z-index: 9999;
      pointer-events: none;
    }
    @keyframes floatUp {
      0% {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) translateY(-250px);
      }
    }
    @media (max-width: 600px) {
      .container { padding: 0.5rem; }
      input { width: 100%; margin-bottom: 0.5rem; }
      button, select { width: 100%; margin-bottom: 0.5rem; }
      #sendBtn, #leaveChatBtn, #sendGiftBtn, #likeBtn { font-size: 1rem; }
      .chat { padding: 0.5rem; }
      h1 { font-size: 1.5rem; text-align: center; }
      .video-box { padding: 0.5rem; }
      .viewer-count ul { padding-left: 1rem; }
    }
  </style>
</head>
<body>

{% if not event.is_live and not user_has_paid %}
  <div class="payment-warning">
    âš ï¸ You need to pay <strong>50â€¯KES</strong> to join this conversation.
    <a href="{% url 'pay_event' event.id %}" class="pay-button">Pay with Paystack</a>
  </div>
{% else %}
<div class="container">
  <h1>ğŸ¥ {{ event.title }}</h1>

<div class="video-box">
  {% if user.pk == event.organizer.pk %}
<video id="localVideo" autoplay muted playsinline></video>

<button onclick="startMuxBroadcast()" style="background:limegreen;color:black;padding:0.5rem 1rem;margin:1rem 0;">ğŸ¥ Go Live from Browser</button>

<form method="post" action="{% url 'end_event' event.id %}">
  {% csrf_token %}
  <button type="submit" style="background:red;color:white;padding:0.5rem 1rem;">ğŸ”´ End Live</button>
</form>

<p><strong>Or use Stream Key:</strong> {{ event.mux_stream_key }}</p>
<p>Use OBS or stream from your browser ğŸ‘†</p>

    <div id="videoPlaceholder">ğŸ”´ Waiting for organizerâ€™s live video...</div>
    {% if event.mux_playback_id %}
      <video
        id="viewerStream"
        autoplay
        controls
        playsinline
        style="width:100%;border-radius:1rem;"
        src="https://stream.mux.com/{{ event.mux_playback_id }}.m3u8">
      </video>
    {% else %}
      <p>Live stream not yet started.</p>
    {% endif %}
    <video id="localVideo" autoplay muted playsinline style="display:none;"></video>
    <button id="requestMicBtn" class="mic-request-btn">ğŸ™ï¸ Request to Speak</button>
  {% endif %}
</div>



  <div class="viewer-count">
    {% if user.pk == event.organizer.pk and participants %}
      ğŸ‘ï¸ Viewers: {{ participants|length }}
      <div><strong>Joined Participants:</strong>
        <ul>{% for p in participants %}<li>ğŸŸ¢ {{ p.user.username }}</li>{% endfor %}</ul>
      </div>
    {% else %}
      ğŸ‘ï¸ Viewers: {{ participant_count }}
    {% endif %}
  </div>

  {% if user.pk == event.organizer.pk %}
    <div id="micRequests">
      <h3>ğŸ¤ Mic Requests</h3>
      <ul id="requestList"></ul>
    </div>
  {% endif %}

  <button id="likeBtn">â¤ï¸ Like (<span id="likeCount">0</span>)</button>

  <div class="chat">
    <div id="chatArea" style="height:150px;overflow-y:auto;"></div>
    <input type="text" id="messageInput" placeholder="Type message...">
    <button id="sendBtn">Send</button>
    <button id="leaveChatBtn">Leave Chat</button>

    <form id="giftForm" method="POST" action="/events/{{ event.id }}/gift/">
      {% csrf_token %}
      <select name="amount" id="giftType">
        <option value="10">ğŸŒ¹ Rose (10â€¯KES)</option>
        <option value="20">ğŸ« Chocolate (20â€¯KES)</option>
        <option value="50">â­ Star (50â€¯KES)</option>
      </select>
      <button type="submit" id="sendGiftBtn">Send Gift</button>
    </form>
  </div>
</div>
{% endif %}

<script>
const eventId = "{{ event.id|escapejs }}";
const isOrganizer = "{{ user.pk }}" === "{{ event.organizer.pk }}";
const wsScheme = location.protocol === "https:" ? "wss" : "ws";
const user = "{{ request.user.username|escapejs }}";

const chatSocket = new WebSocket(`${wsScheme}://${location.host}/ws/chat/${eventId}/`);
const likeSocket = new WebSocket(`${wsScheme}://${location.host}/ws/event/${eventId}/`);
const streamSocket = new WebSocket(`${wsScheme}://${location.host}/ws/stream/${eventId}/`);

let liked = false;
let localMicStream = null;
let localStream = null;
const peerConnections = {};
const iceServers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

let streamReady = false;
const pendingOffers = {};

function floatEmoji(content) {
  const el = document.createElement("div");
  el.className = "float-emoji";
  el.innerText = content;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 4000);
}

function giftLabel(value) {
  switch (value) {
    case "10": return "ğŸŒ¹ Coin x10";
    case "20": return "ğŸ« Coin x20";
    case "50": return "â­ Coin x50";
    default: return `ğŸ Coin x${value}`;
  }
}

async function startOrganizerStream() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    console.log("ğŸ“¸ Organizer got local stream:", localStream);
    document.getElementById("localVideo").srcObject = localStream;

    streamReady = true;

    // Process any queued offers
    for (const viewerId in pendingOffers) {
      console.log("ğŸ“¡ Organizer processing pending offer from:", viewerId);
      await handleViewerOffer(viewerId, pendingOffers[viewerId]);
      delete pendingOffers[viewerId];
    }

    likeSocket.send(JSON.stringify({ type: "live_started", event_id: eventId }));
    streamSocket.send(JSON.stringify({ type: "live_started", event_id: eventId }));
  } catch (err) {
    console.error("Failed to start stream:", err);
    alert("Could not access your camera and microphone.");
  }
}

async function handleViewerOffer(viewerId, offer) {
  console.log("ğŸ“¡ Organizer received offer from:", viewerId);
  const pc = new RTCPeerConnection(iceServers);
  peerConnections[viewerId] = pc;

  localStream.getTracks().forEach(track => {
    pc.addTrack(track, localStream);
    console.log("ğŸ”— Organizer added track:", track);
  });

  pc.onicecandidate = e => {
    if (e.candidate) {
      streamSocket.send(JSON.stringify({
        type: "organizer_ice", target: viewerId, candidate: e.candidate
      }));
    }
  };

  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  streamSocket.send(JSON.stringify({
    type: "organizer_answer", target: viewerId, answer: pc.localDescription
  }));
}

function handleViewerIce(viewerId, candidate) {
  const pc = peerConnections[viewerId];
  if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(console.error);
}

async function startViewerStream() {
  const pc = new RTCPeerConnection(iceServers);
  peerConnections["organizer"] = pc;

  pc.onicecandidate = e => {
    if (e.candidate) {
      streamSocket.send(JSON.stringify({
        type: "viewer_ice", viewer_id: user, candidate: e.candidate
      }));
    }
  };

  pc.ontrack = event => {
    const [stream] = event.streams;
    const vid = document.getElementById("viewerStream");
    if (vid && stream) {
      console.log("ğŸ¥ Viewer received stream:", stream);
      vid.srcObject = stream;
      vid.style.display = "block";
      vid.muted = false;
      document.getElementById("videoPlaceholder")?.remove();
    }
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  console.log("ğŸ“¡ Viewer sending offer");
  streamSocket.send(JSON.stringify({
    type: "viewer_offer", viewer_id: user, offer: pc.localDescription
  }));
}

async function handleOrganizerAnswer(answer) {
  const pc = peerConnections["organizer"];
  if (!pc) return console.warn("âš ï¸ No PC for organizer");
  console.log("ğŸ“² Viewer received organizer's answer");
  await pc.setRemoteDescription(new RTCSessionDescription(answer));
}

function handleOrganizerIce(candidate) {
  const pc = peerConnections["organizer"];
  if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(console.error);
}

streamSocket.onopen = () => {
  if (isOrganizer) {
    startOrganizerStream();
  } else {
    streamSocket.send(JSON.stringify({ type: "check_stream", viewer_id: user }));
  }
};

streamSocket.onmessage = async e => {
  const data = JSON.parse(e.data);

  if (data.type === "viewer_offer" && isOrganizer) {
    console.log("ğŸ›° Organizer received viewer_offer");
    if (!streamReady) {
      console.log("â³ Stream not ready, queuing offer for", data.viewer_id);
      pendingOffers[data.viewer_id] = data.offer;
      return;
    }
    await handleViewerOffer(data.viewer_id, data.offer);

  } else if (data.type === "organizer_answer" && !isOrganizer) {
    console.log("ğŸ“² Viewer received organizer_answer");
    await handleOrganizerAnswer(data.answer);

  } else if (data.type === "viewer_ice" && isOrganizer) {
    handleViewerIce(data.viewer_id, data.candidate);

  } else if (data.type === "organizer_ice" && !isOrganizer) {
    handleOrganizerIce(data.candidate);

  } else if ((data.type === "live_started" || data.type === "stream_active") && !isOrganizer) {
    console.log("ğŸš€ Viewer received live_started signal");
    startViewerStream();
  }
};

// CHAT SOCKET
chatSocket.onmessage = event => {
  const data = JSON.parse(event.data);
  if (data.type === "chat") {
    const p = document.createElement("p");
    p.innerHTML = `<strong>${data.username}:</strong> ${data.message}`;
    const chatArea = document.getElementById("chatArea");
    chatArea.appendChild(p);
    chatArea.scrollTop = chatArea.scrollHeight;
  } else if (data.type === "mic_request" && isOrganizer) {
    const li = document.createElement("li");
    li.id = `mic-${data.username}`;
    li.innerHTML = `${data.username} requests mic 
      <button onclick="approveMic('${data.username}')">âœ…</button>
      <button onclick="denyMic('${data.username}')">âŒ</button>`;
    document.getElementById("requestList").appendChild(li);
  } else if (data.type === "mic_approved") {
    if (!isOrganizer && data.username === user) {
      navigator.mediaDevices.getUserMedia({ audio: true, video: true })
        .then(stream => {
          localMicStream = stream;
          const video = document.getElementById("viewerStream");
          video.srcObject = stream;
          video.style.display = "block";
          floatEmoji("ğŸ¤ğŸ¥ You are live!");
        })
        .catch(() => alert("Could not access camera/microphone."));
    } else {
      document.getElementById(`mic-${data.username}`)?.remove();
    }
  } else if (data.type === "mic_denied") {
    if (data.username === user) {
      alert("âŒ Your mic request was denied.");
    } else {
      document.getElementById(`mic-${data.username}`)?.remove();
    }
  } else if (data.type === "mic_revoked" && data.username === user) {
    if (localMicStream) {
      localMicStream.getTracks().forEach(t => t.stop());
    }
    localMicStream = null;
    const video = document.getElementById("viewerStream");
    video.srcObject = null;
    video.style.display = "none";
    alert("ğŸ”‡ Your mic/video access was revoked.");
  }
};

// LIKE SOCKET
likeSocket.onmessage = event => {
  const data = JSON.parse(event.data);
  if (data.type === "like_update") {
    document.getElementById("likeCount").innerText = data.total_likes;
    floatEmoji("â¤ï¸");
  } else if (data.type === "gift") {
    const p = document.createElement("p");
    p.textContent = `ğŸ ${data.user} sent ${giftLabel(data.gift)}`;
    p.style.color = "orange";
    document.getElementById("chatArea").appendChild(p);
    floatEmoji(`ğŸ ${data.user} sent ${giftLabel(data.gift)}`);
  } else if (data.type === "live_started") {
    document.getElementById("videoPlaceholder")?.remove();
  }
};

document.getElementById("sendBtn").onclick = () => {
  const msg = document.getElementById("messageInput").value.trim();
  if (msg && chatSocket.readyState === WebSocket.OPEN) {
    chatSocket.send(JSON.stringify({ type: "message", message: msg }));
    document.getElementById("messageInput").value = "";
  }
};

document.getElementById("messageInput").addEventListener("keypress", e => {
  if (e.key === "Enter") document.getElementById("sendBtn").click();
});

document.getElementById("likeBtn").onclick = () => {
  if (likeSocket.readyState === WebSocket.OPEN) {
    likeSocket.send(JSON.stringify({
      action: liked ? "unlike" : "like",
      event_id: eventId
    }));
    liked = !liked;
    document.getElementById("likeBtn").classList.toggle("liked", liked);
  }
};

function approveMic(username) {
  chatSocket.send(JSON.stringify({ type: "mic_approved", username }));
}
function denyMic(username) {
  chatSocket.send(JSON.stringify({ type: "mic_denied", username }));
}
function revokeMic(username) {
  chatSocket.send(JSON.stringify({ type: "mic_revoked", username }));
}

document.getElementById("leaveChatBtn").onclick = () => {
  window.location.href = "{% url 'landing' %}";
};

const micBtn = document.getElementById("requestMicBtn");
if (micBtn) {
  micBtn.onclick = () => {
    chatSocket.send(JSON.stringify({ type: "mic_request", username: user }));
    micBtn.disabled = true;
  };
}
async function startMuxBroadcast() {
  try {
    const streamKey = "{{ event.mux_stream_key }}";
    const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

    const mux = new MuxLive.MuxRTMPPublisher({
      streamKey: streamKey,
      userMediaStream: mediaStream,
    });

    await mux.start();
    console.log("ğŸ”´ Live broadcast started with Mux WebRTC");

    const video = document.getElementById("localVideo");
    video.srcObject = mediaStream;
    video.muted = true;
    video.style.display = "block";

  } catch (err) {
    console.error("âŒ Failed to start Mux broadcast:", err);
    alert("Could not start broadcast: " + err.message);
  }
}

</script>



</body>
</html>
