<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{ event.title }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/@mux/mux-embed@latest"></script>
  <script src="https://unpkg.com/@mux/mux-rtmp-publisher"></script>
  <!-- Dynamic LiveKit script loading -->
  <script>
    function loadLiveKitScript() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js';
        script.defer = true;
        script.onload = () => resolve();
        script.onerror = () => {
          console.error('Primary CDN failed, trying fallback');
          const fallbackScript = document.createElement('script');
          fallbackScript.src = 'https://unpkg.com/livekit-client@latest/dist/livekit-client.umd.min.js'; // Secondary CDN
          fallbackScript.defer = true;
          fallbackScript.onload = () => resolve();
          fallbackScript.onerror = () => {
            console.error('All CDNs failed');
            alert('Failed to load LiveKit library. Check your internet connection or contact support.');
            reject();
          };
          document.head.appendChild(fallbackScript);
        };
        document.head.appendChild(script);
      });
    }

    // Load LiveKit before inline scripts
    loadLiveKitScript().catch(() => {});
  </script>

  <style>
    body {
      background-color: #000;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 1rem;
    }
    .video-box {
      width: 100%;
      background-color: #111;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      border: 2px solid #333;
      margin-bottom: 1rem;
    }
    #livekit-media video,
    #localVideo,
    #viewerStream {
      width: 100%;
      max-height: 60vh;
      border-radius: 10px;
      border: 2px solid limegreen;
      object-fit: cover;
    }
    .chat {
      background-color: #111;
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
    }
    input, select, button {
      padding: 0.5rem;
      border: none;
      border-radius: 5px;
      margin: 0.2rem;
    }
    input {
      width: 70%;
      background-color: #222;
      color: #fff;
    }
    #sendBtn {
      background-color: limegreen;
      color: #000;
      font-weight: bold;
    }
    #likeBtn {
      background-color: #000;
      color: white;
      border: 2px solid red;
      font-weight: bold;
      transition: background 0.3s, color 0.3s;
    }
    #likeBtn.liked {
      background-color: red;
      color: #fff;
    }
    #leaveChatBtn {
      background-color: #444;
      color: #fff;
      font-weight: bold;
    }
    #sendGiftBtn {
      background-color: orange;
      color: #000;
      font-weight: bold;
    }
    .viewer-count {
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>

{% if not event.is_live and not user_has_paid %}
  <div class="payment-warning">
    âš ï¸ You need to pay <strong>50â€¯KES</strong> to join this conversation.
    <a href="{% url 'pay_event' event.id %}" class="pay-button">Pay with Paystack</a>
  </div>
{% else %}
<div class="container">
  <h1>ğŸ¥ {{ event.title }}</h1>

  <div class="video-box">
    <!-- LiveKit video area -->
    <div id="livekit-media"></div>
    <!-- Organizer stream preview -->
    <video id="localVideo" autoplay muted playsinline style="display: none;"></video>
    <video id="viewerStream" autoplay playsinline style="display: none;"></video>

    {% if user.pk == event.organizer.pk %}
      <form method="post" action="{% url 'end_event' event.id %}">
        {% csrf_token %}
        <button type="submit" style="background:red;color:white;padding:0.5rem 1rem;margin-top:1rem;">ğŸ”´ End Live</button>
      </form>
    {% endif %}
  </div>

  <div class="viewer-count">
    {% if user.pk == event.organizer.pk and participants %}
      ğŸ‘ï¸ Viewers: {{ participants|length }}
      <div><strong>Joined Participants:</strong>
        <ul>{% for p in participants %}<li>ğŸŸ¢ {{ p.user.username }}</li>{% endfor %}</ul>
      </div>
    {% else %}
      ğŸ‘ï¸ Viewers: {{ participant_count }}
    {% endif %}
  </div>

  {% if user.pk == event.organizer.pk %}
    <div id="micRequests">
      <h3>ğŸ¤ Mic Requests</h3>
      <ul id="requestList"></ul>
    </div>
  {% endif %}

  <button id="likeBtn">â¤ï¸ Like (<span id="likeCount">0</span>)</button>

  <div class="chat">
    <div id="chatArea" style="height:150px;overflow-y:auto;"></div>
    <input type="text" id="messageInput" placeholder="Type message...">
    <button id="sendBtn">Send</button>
    <button id="leaveChatBtn">Leave Chat</button>
    <form id="giftForm" method="POST" action="/events/{{ event.id }}/gift/">
      {% csrf_token %}
      <select name="amount" id="giftType">
        <option value="10">ğŸŒ¹ Rose (10â€¯KES)</option>
        <option value="20">ğŸ« Chocolate (20â€¯KES)</option>
        <option value="50">â­ Star (50â€¯KES)</option>
      </select>
      <button type="submit" id="sendGiftBtn">Send Gift</button>
    </form>
  </div>
</div>
{% endif %}

<!-- âœ… LiveKit Connect Script (using lowercase 'livekit' from UMD global) -->
<script>
(async () => {
  // Wait for LiveKit to load
  await new Promise(resolve => {
    const checkLiveKit = setInterval(() => {
      if (typeof livekit !== 'undefined') {
        clearInterval(checkLiveKit);
        resolve();
      }
    }, 100);
    setTimeout(() => {
      clearInterval(checkLiveKit);
      if (typeof livekit === 'undefined') {
        console.error('LiveKit library not loaded after timeout');
        alert('Failed to load LiveKit library. Check your internet connection or contact support.');
      }
    }, 5000); // 5-second timeout
  });

  try {
    const resp = await fetch(`/livekit/token/{{ event.id }}/`);
    const { token, url } = await resp.json();

    const room = new livekit.Room({
      adaptiveStream: true,
      dynacast: true,
    });

    const mediaDiv = document.getElementById("livekit-media");
    const isOrganizer = "{{ user.pk }}" === "{{ event.organizer.pk }}";

    room.on(livekit.RoomEvent.TrackSubscribed, (track, publication, participant) => {
      const el = track.attach();
      mediaDiv.appendChild(el);
    });

    await room.connect(url, token);

    if (isOrganizer) {
      const localTracks = await livekit.createLocalTracks({
        audio: true,
        video: { resolution: { width: 1280, height: 720 } },
      });

      await room.localParticipant.publishTracks(localTracks);

      localTracks.forEach(track => {
        const el = track.attach();
        mediaDiv.appendChild(el);

        // âœ… show organizer's local video
        const localPreview = document.getElementById("localVideo");
        if (localPreview) {
          localPreview.srcObject = track.mediaStreamTrack ? new MediaStream([track.mediaStreamTrack]) : null;
          localPreview.style.display = "block";
        }
      });
    }

    // Handle existing participants
    room.participants.forEach(participant => {
      participant.tracks.forEach(publication => {
        if (publication.track) {
          const el = publication.track.attach();
          mediaDiv.appendChild(el);
        }
      });
    });

    // Cleanup when participants leave
    room.on(livekit.RoomEvent.ParticipantDisconnected, participant => {
      participant.tracks.forEach(pub => {
        const els = pub.track?.detach?.() || [];
        els.forEach(el => el.remove());
      });
    });

  } catch (err) {
    console.error("âŒ LiveKit connection error:", err);
    alert("Failed to join stream. Make sure camera and mic permissions are allowed.");
  }
})();
</script>

<script>
const eventId = "{{ event.id|escapejs }}";
const isOrganizer = "{{ user.pk }}" === "{{ event.organizer.pk }}";
const wsScheme = location.protocol === "https:" ? "wss" : "ws";
const user = "{{ request.user.username|escapejs }}";

const chatSocket = new WebSocket(`${wsScheme}://${location.host}/ws/chat/${eventId}/`);
const likeSocket = new WebSocket(`${wsScheme}://${location.host}/ws/event/${eventId}/`);
const streamSocket = new WebSocket(`${wsScheme}://${location.host}/ws/stream/${eventId}/`);

let liked = false;
let localMicStream = null;
const peerConnections = {};
const iceServers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
let streamReady = false, pendingOffers = {};

function floatEmoji(content) {
  const el = document.createElement("div");
  el.className = "float-emoji";
  el.innerText = content;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 4000);
}

function giftLabel(value) {
  switch (value) {
    case "10": return "ğŸŒ¹ Coin x10";
    case "20": return "ğŸ« Coin x20";
    case "50": return "â­ Coin x50";
    default: return `ğŸ Coin x${value}`;
  }
}

async function startOrganizerStream() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    console.log("ğŸ“¸ Organizer got local stream:", localStream);
    document.getElementById("localVideo").srcObject = localStream;

    streamReady = true;

    // Process any queued offers
    for (const viewerId in pendingOffers) {
      console.log("ğŸ“¡ Organizer processing pending offer from:", viewerId);
      await handleViewerOffer(viewerId, pendingOffers[viewerId]);
      delete pendingOffers[viewerId];
    }

    likeSocket.send(JSON.stringify({ type: "live_started", event_id: eventId }));
    streamSocket.send(JSON.stringify({ type: "live_started", event_id: eventId }));
  } catch (err) {
    console.error("Failed to start stream:", err);
    alert("Could not access your camera and microphone.");
  }
}

async function handleViewerOffer(viewerId, offer) {
  console.log("ğŸ“¡ Organizer received offer from:", viewerId);
  const pc = new RTCPeerConnection(iceServers);
  peerConnections[viewerId] = pc;

  localStream.getTracks().forEach(track => {
    pc.addTrack(track, localStream);
    console.log("ğŸ”— Organizer added track:", track);
  });

  pc.onicecandidate = e => {
    if (e.candidate) {
      streamSocket.send(JSON.stringify({
        type: "organizer_ice", target: viewerId, candidate: e.candidate
      }));
    }
  };

  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  streamSocket.send(JSON.stringify({
    type: "organizer_answer", target: viewerId, answer: pc.localDescription
  }));
}

function handleViewerIce(viewerId, candidate) {
  const pc = peerConnections[viewerId];
  if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(console.error);
}

async function startViewerStream() {
  const pc = new RTCPeerConnection(iceServers);
  peerConnections["organizer"] = pc;

  pc.onicecandidate = e => {
    if (e.candidate) {
      streamSocket.send(JSON.stringify({
        type: "viewer_ice", viewer_id: user, candidate: e.candidate
      }));
    }
  };

  pc.ontrack = event => {
    const [stream] = event.streams;
    const vid = document.getElementById("viewerStream");
    if (vid && stream) {
      console.log("ğŸ¥ Viewer received stream:", stream);
      vid.srcObject = stream;
      vid.style.display = "block";
      vid.muted = false;
      document.getElementById("videoPlaceholder")?.remove();
    }
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  console.log("ğŸ“¡ Viewer sending offer");
  streamSocket.send(JSON.stringify({
    type: "viewer_offer", viewer_id: user, offer: pc.localDescription
  }));
}

async function handleOrganizerAnswer(answer) {
  const pc = peerConnections["organizer"];
  if (!pc) return console.warn("âš ï¸ No PC for organizer");
  console.log("ğŸ“² Viewer received organizer's answer");
  await pc.setRemoteDescription(new RTCSessionDescription(answer));
}

function handleOrganizerIce(candidate) {
  const pc = peerConnections["organizer"];
  if (pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(console.error);
}

streamSocket.onopen = () => {
  if (isOrganizer) {
    startOrganizerStream();
  } else {
    streamSocket.send(JSON.stringify({ type: "check_stream", viewer_id: user }));
  }
};

streamSocket.onmessage = async e => {
  const data = JSON.parse(e.data);

  if (data.type === "viewer_offer" && isOrganizer) {
    console.log("ğŸ›° Organizer received viewer_offer");
    if (!streamReady) {
      console.log("â³ Stream not ready, queuing offer for", data.viewer_id);
      pendingOffers[data.viewer_id] = data.offer;
      return;
    }
    await handleViewerOffer(data.viewer_id, data.offer);

  } else if (data.type === "organizer_answer" && !isOrganizer) {
    console.log("ğŸ“² Viewer received organizer_answer");
    await handleOrganizerAnswer(data.answer);

  } else if (data.type === "viewer_ice" && isOrganizer) {
    handleViewerIce(data.viewer_id, data.candidate);

  } else if (data.type === "organizer_ice" && !isOrganizer) {
    handleOrganizerIce(data.candidate);

  } else if ((data.type === "live_started" || data.type === "stream_active") && !isOrganizer) {
    console.log("ğŸš€ Viewer received live_started signal");
    startViewerStream();
  }
};

// CHAT SOCKET
chatSocket.onmessage = event => {
  const data = JSON.parse(event.data);
  if (data.type === "chat") {
    const p = document.createElement("p");
    p.innerHTML = `<strong>${data.username}:</strong> ${data.message}`;
    const chatArea = document.getElementById("chatArea");
    chatArea.appendChild(p);
    chatArea.scrollTop = chatArea.scrollHeight;
  } else if (data.type === "mic_request" && isOrganizer) {
    const li = document.createElement("li");
    li.id = `mic-${data.username}`;
    li.innerHTML = `${data.username} requests mic 
      <button onclick="approveMic('${data.username}')">âœ…</button>
      <button onclick="denyMic('${data.username}')">âŒ</button>`;
    document.getElementById("requestList").appendChild(li);
  } else if (data.type === "mic_approved") {
    if (!isOrganizer && data.username === user) {
      navigator.mediaDevices.getUserMedia({ audio: true, video: true })
        .then(stream => {
          localMicStream = stream;
          const video = document.getElementById("viewerStream");
          video.srcObject = stream;
          video.style.display = "block";
          floatEmoji("ğŸ¤ğŸ¥ You are live!");
        })
        .catch(() => alert("Could not access camera/microphone."));
    } else {
      document.getElementById(`mic-${data.username}`)?.remove();
    }
  } else if (data.type === "mic_denied") {
    if (data.username === user) {
      alert("âŒ Your mic request was denied.");
    } else {
      document.getElementById(`mic-${data.username}`)?.remove();
    }
  } else if (data.type === "mic_revoked" && data.username === user) {
    if (localMicStream) {
      localMicStream.getTracks().forEach(t => t.stop());
    }
    localMicStream = null;
    const video = document.getElementById("viewerStream");
    video.srcObject = null;
    video.style.display = "none";
    alert("ğŸ”‡ Your mic/video access was revoked.");
  }
};

// LIKE SOCKET
likeSocket.onmessage = event => {
  const data = JSON.parse(event.data);
  if (data.type === "like_update") {
    document.getElementById("likeCount").innerText = data.total_likes;
    floatEmoji("â¤ï¸");
  } else if (data.type === "gift") {
    const p = document.createElement("p");
    p.textContent = `ğŸ ${data.user} sent ${giftLabel(data.gift)}`;
    p.style.color = "orange";
    document.getElementById("chatArea").appendChild(p);
    floatEmoji(`ğŸ ${data.user} sent ${giftLabel(data.gift)}`);
  } else if (data.type === "live_started") {
    document.getElementById("videoPlaceholder")?.remove();
  }
};

document.getElementById("sendBtn").onclick = () => {
  const msg = document.getElementById("messageInput").value.trim();
  if (msg && chatSocket.readyState === WebSocket.OPEN) {
    chatSocket.send(JSON.stringify({ type: "message", message: msg }));
    document.getElementById("messageInput").value = "";
  }
};

document.getElementById("messageInput").addEventListener("keypress", e => {
  if (e.key === "Enter") document.getElementById("sendBtn").click();
});

document.getElementById("likeBtn").onclick = () => {
  if (likeSocket.readyState === WebSocket.OPEN) {
    likeSocket.send(JSON.stringify({
      action: liked ? "unlike" : "like",
      event_id: eventId
    }));
    liked = !liked;
    document.getElementById("likeBtn").classList.toggle("liked", liked);
  }
};

function approveMic(username) {
  chatSocket.send(JSON.stringify({ type: "mic_approved", username }));
}
function denyMic(username) {
  chatSocket.send(JSON.stringify({ type: "mic_denied", username }));
}
function revokeMic(username) {
  chatSocket.send(JSON.stringify({ type: "mic_revoked", username }));
}

document.getElementById("leaveChatBtn").onclick = () => {
  window.location.href = "{% url 'landing' %}";
};

const micBtn = document.getElementById("requestMicBtn");
if (micBtn) {
  micBtn.onclick = () => {
    chatSocket.send(JSON.stringify({ type: "mic_request", username: user }));
    micBtn.disabled = true;
  };
}
async function startMuxBroadcast() {
  try {
    const streamKey = "{{ event.mux_stream_key }}";
    const mediaStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

    const mux = new MuxLive.MuxRTMPPublisher({
      streamKey: streamKey,
      userMediaStream: mediaStream,
    });

    await mux.start();
    console.log("ğŸ”´ Live broadcast started with Mux WebRTC");

    const video = document.getElementById("localVideo");
    video.srcObject = mediaStream;
    video.muted = true;
    video.style.display = "block";

  } catch (err) {
    console.error("âŒ Failed to start Mux broadcast:", err);
    alert("Could not start broadcast: " + err.message);
  }
}
</script>

</body>
</html>
