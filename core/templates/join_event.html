<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>{{ event.title }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background-color: #000;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 1rem;
    }
    .video-box {
      width: 100%;
      background-color: #111;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      border: 2px solid #333;
      margin-bottom: 1rem;
    }
    #localVideo, #viewerStream {
      width: 100%;
      border-radius: 10px;
      border: 2px solid limegreen;
    }
    .chat {
      background-color: #111;
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
    }
    input, select, button {
      padding: 0.5rem;
      border: none;
      border-radius: 5px;
      margin: 0.2rem;
    }
    input {
      width: 70%;
      background-color: #222;
      color: #fff;
    }
    #sendBtn {
      background-color: limegreen;
      color: #000;
      font-weight: bold;
    }
    #likeBtn {
      background-color: red;
      color: #fff;
    }
    #leaveChatBtn {
      background-color: #444;
      color: #fff;
      font-weight: bold;
    }
    #sendGiftBtn {
      background-color: orange;
      color: #000;
      font-weight: bold;
    }
    .viewer-count {
      margin-bottom: 1rem;
    }
    .float-emoji {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2rem;
      animation: floatUp 4s ease-out forwards;
      z-index: 9999;
      pointer-events: none;
    }
    @keyframes floatUp {
      0% {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) translateY(-250px);
      }
    }
    @media (max-width: 600px) {
      .container { padding: 0.5rem; }
      input { width: 100%; margin-bottom: 0.5rem; }
      button, select { width: 100%; margin-bottom: 0.5rem; }
      #sendBtn, #leaveChatBtn, #sendGiftBtn, #likeBtn { font-size: 1rem; }
      .chat { padding: 0.5rem; }
      h1 { font-size: 1.5rem; text-align: center; }
      .video-box { padding: 0.5rem; }
      .viewer-count ul { padding-left: 1rem; }
    }
  </style>
</head>
<body>

{% if not event.is_live and not user_has_paid %}
  <div class="payment-warning">
    âš ï¸ You need to pay <strong>50â€¯KES</strong> to join this conversation.
    <a href="{% url 'pay_event' event.id %}" class="pay-button">Pay with Paystack</a>
  </div>
{% else %}
<div class="container">
  <h1>ğŸ¥ {{ event.title }}</h1>

  <div class="video-box">
    {% if user.pk == event.organizer.pk %}
      <video id="localVideo" autoplay muted playsinline></video>
      <form method="post" action="{% url 'end_event' event.id %}">
        {% csrf_token %}
        <button type="submit" style="background:red;color:white;padding:0.5rem 1rem;margin-top:1rem;">ğŸ”´ End Live</button>
      </form>
    {% else %}
      <div id="videoPlaceholder">ğŸ”’ Waiting for organizerâ€™s live video...</div>
      <video id="viewerStream" autoplay muted style="display:none;margin-top:10px;"></video>
      <button id="requestMicBtn" class="mic-request-btn">ğŸ™ï¸ Request to Speak</button>
    {% endif %}
  </div>

  <div class="viewer-count">
    {% if user.pk == event.organizer.pk and participants %}
      ğŸ‘ï¸ Viewers: {{ participants|length }}
      <div><strong>Joined Participants:</strong>
        <ul>{% for p in participants %}<li>ğŸŸ¢ {{ p.user.username }}</li>{% endfor %}</ul>
      </div>
    {% else %}
      ğŸ‘ï¸ Viewers: {{ participant_count }}
    {% endif %}
  </div>

  {% if user.pk == event.organizer.pk %}
    <div id="micRequests">
      <h3>ğŸ¤ Mic Requests</h3>
      <ul id="requestList"></ul>
    </div>
  {% endif %}

  <button id="likeBtn">â¤ï¸ Like (<span id="likeCount">0</span>)</button>

  <div class="chat">
    <div id="chatArea" style="height:150px;overflow-y:auto;"></div>
    <input type="text" id="messageInput" placeholder="Type message...">
    <button id="sendBtn">Send</button>
    <button id="leaveChatBtn">Leave Chat</button>

    <form id="giftForm" method="POST" action="/events/{{ event.id }}/gift/">
      {% csrf_token %}
      <select name="amount" id="giftType">
        <option value="10">ğŸŒ¹ Rose (10â€¯KES)</option>
        <option value="20">ğŸ« Chocolate (20â€¯KES)</option>
        <option value="50">â­ Star (50â€¯KES)</option>
      </select>
      <button type="submit" id="sendGiftBtn">Send Gift</button>
    </form>
  </div>
</div>
{% endif %}

<script>
const eventId = "{{ event.id|escapejs }}";
const isOrganizer = "{{ user.pk }}" === "{{ event.organizer.pk }}";
const wsScheme = location.protocol === "https:" ? "wss" : "ws";
const user = "{{ request.user.username|escapejs }}";

const chatSocket = new WebSocket(`${wsScheme}://${location.host}/ws/chat/${eventId}/`);
const likeSocket = new WebSocket(`${wsScheme}://${location.host}/ws/event/${eventId}/`);
const streamSocket = new WebSocket(`${wsScheme}://${location.host}/ws/stream/${eventId}/`);

let liked = false;
let localMicStream = null;   // For mic granted viewers
let localStream = null;      // Organizer's camera+mic stream
const peerConnections = {};  // organizer: viewerIdâ†’pc; viewer: 'organizer'â†’pc

// STUN servers for WebRTC NAT traversal
const iceServers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

function floatEmoji(content) {
  const el = document.createElement("div");
  el.className = "float-emoji";
  el.innerText = content;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 4000);
}

function giftLabel(value) {
  switch (value) {
    case "10": return "ğŸŒ¹ Coin x10";
    case "20": return "ğŸ« Coin x20";
    case "50": return "â­ Coin x50";
    default: return `ğŸ Coin x${value}`;
  }
}

// --- ORGANIZER: Start local camera+mic and notify live started ---
async function startOrganizerStream() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    const localVideo = document.getElementById("localVideo");
    if (localVideo) localVideo.srcObject = localStream;

    // Notify backend/viewers live started
    likeSocket.send(JSON.stringify({ type: "live_started", event_id: eventId }));
    streamSocket.send(JSON.stringify({ type: "live_started", event_id: eventId }));
  } catch {
    alert("Unable to access your camera/microphone.");
  }
}

// --- ORGANIZER: Handle viewer's WebRTC offer ---
async function handleViewerOffer(viewerId, offer) {
  console.log(`Organizer got offer from viewer ${viewerId}`);
  const pc = new RTCPeerConnection(iceServers);

  // Add local organizer tracks (camera+mic) to send
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  // Send ICE candidates to viewer
  pc.onicecandidate = event => {
    if (event.candidate) {
      streamSocket.send(JSON.stringify({
        type: "organizer_ice",
        candidate: event.candidate,
        target: viewerId
      }));
    }
  };

  // Cleanup on disconnect
  pc.onconnectionstatechange = () => {
    if (pc.connectionState === "disconnected" || pc.connectionState === "failed") {
      pc.close();
      delete peerConnections[viewerId];
      console.log(`Peer with viewer ${viewerId} closed`);
    }
  };

  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  peerConnections[viewerId] = pc;

  // Send answer back to viewer
  streamSocket.send(JSON.stringify({
    type: "organizer_answer",
    answer: pc.localDescription,
    target: viewerId
  }));
}

// --- ORGANIZER: Add ICE candidate from viewer ---
function handleViewerIce(viewerId, candidate) {
  const pc = peerConnections[viewerId];
  if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(console.error);
}

// --- VIEWER: Start peer connection and send offer to organizer ---
async function startViewerStream() {
  const pc = new RTCPeerConnection(iceServers);
  peerConnections["organizer"] = pc;

  // Send ICE candidates to organizer
  pc.onicecandidate = event => {
    if (event.candidate) {
      streamSocket.send(JSON.stringify({
        type: "viewer_ice",
        candidate: event.candidate,
        viewer_id: user
      }));
    }
  };

  // When organizer's stream arrives, show it
  pc.ontrack = event => {
    const viewerVideo = document.getElementById("viewerStream");
    if (viewerVideo.srcObject !== event.streams[0]) {
      viewerVideo.srcObject = event.streams[0];
      viewerVideo.style.display = "block";
    }
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  streamSocket.send(JSON.stringify({
    type: "viewer_offer",
    offer: pc.localDescription,
    viewer_id: user
  }));
}

// --- VIEWER: Handle answer from organizer ---
async function handleOrganizerAnswer(answer) {
  const pc = peerConnections["organizer"];
  if (!pc) return console.error("No organizer peer connection");
  await pc.setRemoteDescription(new RTCSessionDescription(answer));
}

// --- VIEWER: Add ICE candidate from organizer ---
function handleOrganizerIce(candidate) {
  const pc = peerConnections["organizer"];
  if (!pc) return console.error("No organizer peer connection");
  pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(console.error);
}

// --- WEBSOCKET HANDLERS ---

streamSocket.onopen = () => {
  console.log("Stream socket connected");
  if (isOrganizer) startOrganizerStream();
};

streamSocket.onmessage = async event => {
  const data = JSON.parse(event.data);
  console.log("Stream message:", data);

  if (data.type === "viewer_offer" && isOrganizer) {
    await handleViewerOffer(data.viewer_id, data.offer);
  } else if (data.type === "organizer_answer" && !isOrganizer) {
    await handleOrganizerAnswer(data.answer);
  } else if (data.type === "viewer_ice" && isOrganizer) {
    handleViewerIce(data.viewer_id, data.candidate);
  } else if (data.type === "organizer_ice" && !isOrganizer) {
    handleOrganizerIce(data.candidate);
  } else if (data.type === "live_started" && !isOrganizer) {
    startViewerStream();
    const placeholder = document.getElementById("videoPlaceholder");
    if (placeholder) placeholder.remove();
  }
};

streamSocket.onclose = () => console.warn("Stream socket closed");
streamSocket.onerror = e => console.error("Stream socket error", e);

chatSocket.onmessage = event => {
  const data = JSON.parse(event.data);

  if (data.type === "chat") {
    const p = document.createElement("p");
    p.innerHTML = `<strong>${data.username}:</strong> ${data.message}`;
    const chatArea = document.getElementById("chatArea");
    chatArea.appendChild(p);
    chatArea.scrollTop = chatArea.scrollHeight;
  } else if (data.type === "mic_request" && isOrganizer) {
    const li = document.createElement("li");
    li.id = `mic-${data.username}`;
    li.innerHTML = `${data.username} wants to speak
      <button onclick="approveMic('${data.username}')">âœ… Approve</button>
      <button onclick="denyMic('${data.username}')">âŒ Deny</button>`;
    document.getElementById("requestList").appendChild(li);
  } else if (data.type === "mic_approved") {
    if (!isOrganizer && data.username === user) {
      navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
        localMicStream = stream;
        const video = document.getElementById("viewerStream");
        video.srcObject = stream;
        video.style.display = "block";
        floatEmoji("ğŸ¤ You are live!");
      }).catch(() => alert("Could not access microphone."));
    } else {
      const el = document.getElementById(`mic-${data.username}`);
      if (el) el.remove();
    }
  } else if (data.type === "mic_denied") {
    if (data.username === user) alert("âŒ Your mic request was denied.");
    else {
      const el = document.getElementById(`mic-${data.username}`);
      if (el) el.remove();
    }
  } else if (data.type === "mic_revoked" && data.username === user) {
    if (localMicStream) localMicStream.getTracks().forEach(t => t.stop());
    document.getElementById("viewerStream").style.display = "none";
    alert("ğŸ”‡ Your mic access was revoked.");
  }
};

likeSocket.onmessage = event => {
  const data = JSON.parse(event.data);
  if (data.type === "like_update") {
    document.getElementById("likeCount").innerText = data.total_likes;
    floatEmoji("â¤ï¸");
  } else if (data.type === "gift") {
    const p = document.createElement("p");
    p.textContent = `ğŸ ${data.user} sent ${giftLabel(data.gift)}`;
    p.style.color = "orange";
    document.getElementById("chatArea").appendChild(p);
    floatEmoji(`ğŸ ${data.user} sent ${giftLabel(data.gift)}`);
  } else if (data.type === "live_started") {
    const placeholder = document.getElementById("videoPlaceholder");
    if (placeholder) placeholder.remove();
  }
};

document.getElementById("sendBtn").onclick = () => {
  const msg = document.getElementById("messageInput").value.trim();
  if (msg && chatSocket.readyState === WebSocket.OPEN) {
    chatSocket.send(JSON.stringify({ type: "message", message: msg }));
    document.getElementById("messageInput").value = "";
  }
};

document.getElementById("messageInput").addEventListener("keypress", e => {
  if (e.key === "Enter") document.getElementById("sendBtn").click();
});

document.getElementById("likeBtn").onclick = () => {
  if (likeSocket.readyState === WebSocket.OPEN) {
    likeSocket.send(JSON.stringify({ action: liked ? "unlike" : "like", event_id: eventId }));
    liked = !liked;
  }
};

function approveMic(username) {
  chatSocket.send(JSON.stringify({ type: "mic_approved", username }));
}
function denyMic(username) {
  chatSocket.send(JSON.stringify({ type: "mic_denied", username }));
}
function revokeMic(username) {
  chatSocket.send(JSON.stringify({ type: "mic_revoked", username }));
}

document.getElementById("leaveChatBtn").onclick = () => {
  window.location.href = "{% url 'landing' %}";
};

const micBtn = document.getElementById("requestMicBtn");
if (micBtn) {
  micBtn.onclick = () => {
    chatSocket.send(JSON.stringify({ type: "mic_request", username: user }));
    micBtn.disabled = true;
  };
}
</script>


</body>
</html>
